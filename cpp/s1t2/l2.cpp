//Спринт 3/22: Спринт 1 → Тема 2/5: Структуры и классы → Урок 2/11

Недостатки пар
В прошлой теме вы научили свою поисковую систему показывать самые релевантные результаты. Для этого вы использовали пару целых чисел {document_id, relevance}. Функция FindTopDocuments стала выглядеть так:
// Возвращает топ-5 самых релевантных документов в виде пар: {id, релевантность}
vector<pair<int, int>> FindTopDocuments(
    const vector<pair<int, vector<string>>>& documents,
    const set<string>& stop_words,
    const string& raw_query); 
Но у контейнера pair есть недостатки.
Непонятность. Например, без комментария неясно, что хранится в pair<int, int>. Но комментарии ненадёжны. Если второй int станет обозначать возраст, а не релевантность, разработчик может забыть обновить комментарий. Тогда об изменениях никто не узнает. Этот недостаток виден в коде выше.
Непрозрачность. В некоторых сценариях она доходит до криптографичности, как в этом коде обработки результата функции:
for (const pair<int, int>& document : FindTopDocuments(documents, stop_words, query)) {
     if (document.second > THRESHOLD) {
             cout << document.first << endl;
     }
} 
 Нужны дополнительные комментарии, чтобы понять, что за first и second и в чём смысл сравнения second с неким порогом. Проще было бы воспринимать такое тело цикла:
if (document.relevance > THRESHOLD) {
     cout << document.id << endl;
}
  
 Тогда будет ясно: в цикле выводятся id всех документов с достаточно высокой релевантностью.
Трудоёмкость внесения изменений. Если захотите вместо int поставить тип релевантности double, pair<int, int> придётся везде заменить на pair<int, double>. Особенно неприятно, когда пара int хранит в программе что-нибудь ещё. Например, рост и возраст человека.
Такие же недостатки есть и у пары pair<int, vector<string>>, которая хранит id документа и список слов. Можно ввести синоним для этого типа, используя ключевое слово using, и немного улучшить читаемость кода:
using DocumentContent = pair<int, vector<string>>;
using Document = pair<int, int>;
// Теперь везде вместо pair<int, int> можно использовать тип Document,
// а вместо pair<int, vector<string>> - DocumentContent
vector<Document> FindTopDocuments(const vector<DocumentContent>& documents,
    const set<string>& stop_words, const string& raw_query) { 
    ... 
} 
При этом места, обращающиеся к полям first и second, будут по-прежнему читаться с трудом:
vector<Document> FindAllDocuments(const vector<DocumentContent>& documents,
                                  const set<string>& query_words) {
    vector<pair<int, int>> matched_documents;
    for (const auto& document : documents) {
        const int relevance = MatchDocument(document, query_words);
        if (relevance > 0) {
            // В этом месте неочевидно, что такое document.first
            matched_documents.push_back({relevance, document.first});
        }
    }
    return matched_documents;
} 
Пары — полезный контейнер со своей областью применения. Но для данного этапа разработки поисковой системы больше подойдёт другой тип данных.
Вспомните всё, что знаете о контейнере pair. Отметьте причины, по которым пары плохо подходят для хранения информации об объекте.


Правильный ответ
По названию типа pair<...> непонятно, какой объект скрывается за этими двумя полями.
А текстовых комментариев на все не напишешь.

Правильный ответ
По названиям полей first и second непонятно, что в них хранится.
И тут нужны текстовые комментарии. Когда же писать сам код?

К полям пары нельзя обратиться напрямую.

Неправильный ответ
Пару тяжело создать «на лету» из двух переменных: например, чтобы передать в push_back.
Напротив, здесь отлично справляются фигурные скобки: documents.push_back({document_id, relevance})

Правильный ответ
Нельзя добавить третье поле.
Третий в паре — лишний!

Правильный ответ
При необходимости изменить тип одного из полей придётся делать это в нескольких местах программы.
И лучше сразу перестать себя обманывать и завести для документа отдельный тип.

Пары — маргинальный контейнер и даже не применяются в стандартных алгоритмах и контейнерах.