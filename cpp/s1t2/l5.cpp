//Спринт 3/22: Спринт 1 → Тема 2/5: Структуры и классы → Урок 5/11

Ограничения структур
В прошлых уроках вы познакомились со структурами. Они позволяют создавать объекты-агрегаты — сложные объекты, состоящие из нескольких простых. Например, структура DocumentContent объединяет id документа и входящие в него слова в один объект:
struct DocumentContent {
    int id;
    vector<string> words;
}; 
Вы можете обращаться к полям структур напрямую, указывая их через точку:
DocumentContent content;
content.id = 42;
content.words.push_back("cat"s); 
Этих возможностей вполне достаточно, если поля структуры могут принимать произвольные значения и не зависят друг от друга. Но так бывает не всегда. Представьте, что вам понадобилось хранить дату добавления документа. Для этого вы создаёте структуру Date:
struct Date {
    int year;
    int month; // Месяц от 1 до 12
    int day;   // День от 1 до числа дней в этом месяце
}; 
Начав использовать структуру Date, вы столкнётесь с трудностями:
month и day не должны принимать произвольные значения.
Поле day может принимать значения в диапазоне от 1 до N, где N — количество дней в месяце month года year.
Как можно решить эти трудности и продолжить использовать структуру Date?


Очень внимательно писать код, проверять корректность значений, которые вы записываете в поля структуры Date

Правильный ответ
Написать функции для работы со структурой Date и использовать их.
Функции для работы со структурой Date можно написать один раз, а использовать в коде многократно:
// Инициализирует дату
void SetDate(Date& date, int year, int month, int day) { /*...*/ }

// Возвращает следующую дату
Date GetNextDate(const Date& date) { /*...*/ } 
То, что к полям структуры можно обратиться напрямую, может создать проблемы, даже если вы только считываете значения полей. Ваш код зависит от внутренностей структуры. Если вы измените внутренности структуры, то код, который её использует, тоже нужно будет менять.
Предположим, что в примере со структурой Date вы решили, что удобнее хранить дату как смещение относительно некоторой даты. И тогда код, который обращался к старым полям напрямую, перестанет компилироваться:
struct Date {
    int days_since_1970; // Количество дней с 1 января 1970 года
};

int main() {
    Date d;
    /* ... */

    // Это код не будет компилироваться, так как в структуре Date
    // больше нет полей year, month и day.
    cout << d.year << "."s << d.month << "."s << d.day << endl;
} 
Хотелось бы изменять внутреннее устройство даты, не затрагивая код, который её использует.
К счастью, в C++ есть решение этой проблемы — классы. Познакомимся с ними в следующем уроке.
