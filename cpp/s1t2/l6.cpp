//Спринт 3/22: Спринт 1 → Тема 2/5: Структуры и классы → Урок 6/11

Классы
Класс, как и структура, служит для объявления пользовательского типа, который агрегирует несколько простых объектов в составной. Класс объявляется аналогично структуре, только используется ключевое слово class.
Предположим, что у вас в программе уже была структура Time, которая хранила время в пределах суток.
struct Time {
    int hours;   // Часы от 0 до 23
    int minutes; // Минуты от 0 до 59
    int seconds; // Секунды от 0 до 59
}; 
Чтобы превратить её в класс, проделаем пару манипуляций:
заменим struct на class,
добавим _ к именам полей. Это изменение необязательно. Оно связано с оформлением кода в Практикуме.
class Time {
    int hours_;
    int minutes_;
    int seconds_;
}; 
После замены struct на class мы больше не можем обратиться к полям Time:
int main() {
    Time t;
    cout << t.hours_ << ':' << t.minutes_ << ':' << t.seconds_ << endl;
} 
Компилятор сообщает нам, что поля hours_, minutes_ и seconds_ — частная собственность (англ. private — частный, приватный, личный) класса Time:
main.cpp:12:15: error: 'int Time::hours_' is private within this context
   12 |     cout << t.hours_ << ':' << t.minutes_ << ':' << t.seconds_ << endl;
      |               ^~~~~
main.cpp:7:9: note: declared private here
    7 |     int hours_;
      |         ^~~~~
... 
Если содержимое структуры изначально открыто, то содержимое класса, наоборот, скрыто от внешнего мира. Каждое поле класса имеет определённый уровень доступа. Уровни доступа можно менять, добавляя следующие спецификаторы доступа:
public: — публичный или открытый уровень доступа. К публичным членам класса и структуры можно обращаться отовсюду. В структурах это уровень доступа по умолчанию.
private: — приватный или закрытый уровень доступа. К приватным членам класса нельзя обратиться из кода за пределами класса. В классах этот уровень доступа установлен по умолчанию.
protected: — защищённый уровень доступа. Его рассмотрим позднее.
Если мы наденем волшебные очки, позволяющие увидеть программу глазами компилятора, то обнаружим такие различия между классами и структурами:
Структура:
struct Time {
// Этот спецификатор public: мы видим только благодаря волшебным очкам.
// Он неявно подразумевается внутри struct.
public:
    // Всё, что ниже public:, доступно для внешнего кода
    int hours;
    int minutes;
    int seconds;
}; 
Класс:
class Time {
// Этот спецификатор private: мы видим только благодаря волшебным очкам.
// Он неявно подразумевается внутри class.
private:
    // Всё, что ниже private:, скрыто от внешнего мира
    int hours_;
    int minutes_;
    int seconds_;
};  
Точно так же, как вы не хотели бы, чтобы к вашему кошельку имели доступ посторонние, класс Time не разрешает внешнему коду обращаться к своим данным. Если часы в программе будут показывать время 82:73:-386, жди беды!
Вместо прямого доступа к своим данным класс предоставляет методы. Метод — это функция, которая объявлена внутри класса или структуры. Методы также называют функциями-членами класса (англ. member functions). К содержимому приватной части класса можно обращаться только из его методов. Поэтому методы класса Time нужно сделать публичными, чтобы с ним можно было взаимодействовать, а поля оставить приватными:
class Time {
// Делаем методы класса Time публичными
public:
    int GetHours() {
        return hours_;
    }
    int GetMinutes() {
        return minutes_;
    }
    int GetSeconds() {
        return seconds_;
    }
    void Set(int hours, int minutes, int seconds) {
        /*
            Здесь может быть проверка корректности параметров,
            но для простоты она пропущена
        */

        // Внутри метода класса Time можно обращаться к членам класса по их имени
        hours_ = hours; // присваиваем полю hours_ значение параметра hours
        minutes_ = minutes;
        seconds_ = seconds;
    }

private:
    int hours_;
    int minutes_;
    int seconds_;
}; 
Теперь в программе появился новый тип: класс Time. Вы можете создать в программе сколько угодно объектов — экземпляров этого класса, просто объявляя переменные типа Time. Точь-в-точь как вы делали это с переменными типа string, set, map или vector.
Чтобы взаимодействовать с объектом, нужно вызывать методы его класса, указывая их через точку после имени объекта:
int main() {
    // Создали объект name — экземпляр класса string
    string name;
    // Вызываем у объекта name метод push_back с параметром 'A'
    name.push_back('A');
} 
С классом Time всё точно так же:
int main() {
    // Объявляем переменную t типа Time.
    Time t;
    // Мы можем взаимодействовать с объектом t, вызывая его методы
    t.Set(23, 59, 59);
    cout << t.GetHours() << ':' << t.GetMinutes() << ':' << t.GetSeconds() << endl;
} 
Теперь всё скомпилируется, программа выведет 23:59:59.
Класс Time состоит из двух частей:
Публичный (или открытый) интерфейс. Методы, расположенные в public: разделе класса, задают набор действий, которые можно выполнить над объектами этого класса. Метод SetTime проверяет значения аргументов и не разрешает установить некорректное время.
Приватная (или закрытая) реализация. В ней спрятаны данные класса, и в обход методов обратиться к ним нельзя.
Рассмотрим на примере телевизора. Внутри он может быть устроен довольно сложно. Однако эта сложность скрыта от пользователя. Чтобы управлять телевизором, у вас есть пульт и несколько кнопок на корпусе. Чтобы изменить громкость или переключить канал, не нужно замыкать проводками контакты на плате телевизора — он от этого сломается. Вместо этого пользуются пультом.
Класс тоже может иметь сложную внутреннюю реализацию, но простой и понятный набор публичных методов.
Методы класса, могут быть не только публичными, но и приватными. Так как к ним нельзя обратиться из кода вне класса, приватные методы играют вспомогательную роль. Они позволяют публичным и защищённым методам класса реализовывать свою функциональность:
// Преобразует смещение из формата чч:мм:сс в секунды
int GetTimeOffset(int hours, int minutes, int seconds) {
    return (hours * MINUTES_IN_HOUR + minutes) * SECONDS_IN_MINUTE + seconds;
}

class Time {
public:
    /* ... */

    // Увеличиваем время на заданное смещение
    void Add(int hours, int minutes, int seconds) {
        // Текущее время в секундах после полуночи
        const int current_timestamp = GetTimestamp();
        // Смещение в секундах
        const int offset = GetTimeOffset(hours, minutes, seconds);
        // Изменяем текущее время
        SetTimestamp(current_timestamp + offset);
    }

    // Уменьшаем время на заданное смещение
    void Sub(int hours, int minutes, int seconds) {
        const int current_timestamp = GetTimestamp();
        const int offset = TimeToTimestamp(hours, minutes, seconds);
        SetTimestamp(current_timestamp - offset);
    }

private:
    // Возвращает текущее время в секундах относительно полуночи
    int GetTimestamp() {
        return GetTimeOffset(hours_, minutes_, seconds_);
    }

    // Задаёт время, используя смещение в секундах с начала суток
    void SetTimestamp(int timestamp) {
        // "заворачиваем" смещение вокруг полуночи
        timestamp = ((timestamp % SECONDS_IN_DAY) + SECONDS_IN_DAY) % SECONDS_IN_DAY;

        hours_ = timestamp / SECONDS_IN_HOUR;
        minutes_ = (timestamp / SECONDS_IN_MINUTE) % MINUTES_IN_HOUR;
        seconds_ = timestamp % SECONDS_IN_MINUTE;
    }

    /* ... */
}

int main() {
    Time t;
    t.SetTime(23, 59, 45);
    t.Add(0, 0, 15);
    // Напечатает 0:0:0
    cout << t.GetHours() << ':' << t.GetMinutes() << ':' << t.GetSeconds() << endl;
} 
Инициализация полей класса
Если поля класса имеют примитивный тип, например, int, bool, double или float, их изначальные значения будут неопределёнными. В этой программе мы не вызвали метод Set, чтобы установить время:
int main() {
    Time t;
    cout << t.GetHours() << ':' << t.GetMinutes() << ':' << t.GetSeconds() << endl;
} 
Программа выведет мусор, например:
92394:4198848:-34879243 
Поэтому лучше задать этим полям некоторое ожидаемое начальное значение. Для класса Time подходящим значением по умолчанию будет полночь (00:00:00).
class Time {
    /* ... */
private:
    int hours_ = 0;
    int minutes_ = 0;
    int seconds_ = 0;
};

int main() {
    Time t;
    // Выведет 0:0:0
    cout << t.GetHours() << ':' << t.GetMinutes() << ':' << t.GetSeconds() << endl;
} 
С полями, тип которых — класс, дело обстоит иначе: они имеют значение по умолчанию. Например, у поля типа string значение по умолчанию — пустая строка, у поля типа vector — пустой вектор, а у поля типа Time — полночь:
// Класс Person
class Person {
    ...
    string name_;    // Имя по умолчанию — пустая строка
    string address_; // Адрес по умолчанию — пустая строка
    int age_ = 0;    // Для поля «возраст» явно задаём значение по умолчанию
}; 
Стиль именования классов
Обратите внимание на символ подчёркивания, который мы добавили к названию полей класса. Так внутри методов легче понять, что мы обращаемся к полю класса, а не к локальной переменной или параметру метода:
// Принятый в Яндекс Практикуме стиль написания кода

// Классы имеют стиль именования UpperCamelCase
class Time { // Фигурная скобка открывается на той же строке
public:
    // Методы именуются, как ОбычныеФункции
    void Set(int hours, int minutes, int seconds) {
        // Так как поля класса именуются с подчёркиванием на конце,
        // а локальные переменные и параметры методов без него, понятно,
        // что код присваивает полям класса переданные снаружи аргументы
        hours_ = hours;
        minutes_ = minutes;
        seconds_ = seconds;
    }
private:
    // Приватные поля классов мы будем записывать строчными_буквами_с_подчёркиванием_в_конце_
    int hours_;
    int minutes_;
    int seconds_;
}; 
В нашем курсе мы будем придерживаться такого стиля.
А сейчас напишем в первый раз первый класс.
