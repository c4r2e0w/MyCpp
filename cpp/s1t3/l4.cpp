//Спринт 3/22: Спринт 1 → Тема 3/5: Лямбда-функции → Урок 4/12

Сложные лямбда-функции
Лямбда-функции, которые мы рассмотрели, были довольно простыми: содержали максимум одну инструкцию return. Однако ограничений на использование возможностей языка внутри лямбда-функций практически нет. Вы можете применять циклы, ветвления, вызовы функций так же, как делаете это с обычными функциями.
Эта программа сортирует три числа с помощью лямбда-функции sort3.
#include <iostream>

using namespace std;

int main() {
    auto sort3 = [](int& x, int& y, int& z) {
        if (x > y) {    // Если первые два числа неупорядочены,
            swap(x, y); // то обмениваем их
        }
        // Гарантируется, что x < y

        if (y > z) {    // Упорядочиваем второе и третье число
            swap(y, z);
        }
        // Гарантируется, что x < z и y < z.

        if (x > y) {    // Упорядочиваем x и y
            swap(x, y);
        }
        // Гарантируется, что x < y < z
    };

    int number1 = 10;
    int number2 = 8;
    int number3 = 42;

    sort3(number1, number2, number3);

    cout << number1 << ", "sv << number2 << ", " << number3 << endl;
    // Выведет 8, 10, 42
} 
Тело функции сортировки увеличивает размеры содержащей её функции, и усложняет чтение кода. Поэтому рекомендация остаётся прежней: старайтесь делать лямбда функции как можно короче. Если обычная функция сделает код понятнее, отдавайте предпочтение ей. Например, предыдущая программа только выиграет от замены лямбда-функции на обычную:
void Sort3(int& x, int& y, int& z) {
    if (x > y) {
        swap(x, y);
    }
    if (y > z) {
        swap(y, z);
    }
    if (x > y) {
        swap(x, y);
    }
}

int main() {
    int number1 = 10;
    int number2 = 8;
    int number3 = 42;

    Sort3(number1, number2, number3);

    cout << number1 << ", "sv << number2 << ", " << number3 << endl;
} 
