Сортируем строки без учёта регистра
Рассмотрим программу:
int main() {
    vector<string> animals{ "Zebra"s, "Apple"s, "cat"s, "dog", "crocodile"s, "tiger"s };
    sort(animals.begin(), animals.end());
    for (const string& animal : animals) {
        cout << animal << ' ';
    }
} 
Она отсортирует и выведет названия животных в алфавитном порядке:
Apple Zebra cat crocodile dog tiger  
Слово Zebra выведено перед словом cat, так как в кодировке ASCII символы заглавных букв предшествуют символам строчных.
Чтобы отсортировать строки без учёта регистра символов, можно было бы привести строки к нижнему регистру, прежде чем выполнить сравнение.
#include <cctype> // содержит функцию tolower.

using namespace std;

// Приводит строку к нижнему регистру
string ToLowerCase(string s) {
    for (char& ch : s) {
        ch = tolower(static_cast<unsigned char>(ch));
    }
    return s;
}

int main() {
    ...
    sort(animals.begin(), animals.end(),
        [](const string& left, const string& right) {
            return ToLowerCase(left) < ToLowerCase(right);
        });
    ...
} 
Здесь в функцию сортировки в качестве компаратора передаётся лямбда-функция, в которой строки перед сравнением переводятся в нижний регистр. Для этого ToLowerCase для каждого символа строки вызывает библиотечную функцию tolower. tolower принимает целое число — код символа и возвращает код этого символа в нижнем регистре. Например, tolower('F') вернёт символ 'f'. Для символов, у которых отсутствует понятие «нижний регистр», будет возвращён исходный код символа. Например, для цифр или знаков пунктуации.
После этих манипуляций строки Zebra, и cat будут сравниваться как zebra и cat. Программа отсортирует строки без учёта регистра символов.
«Магия» со static_cast нужна, чтобы функция tolower корректно работала с символами вне стандартной кодировки ASCII. Если гарантируется, что строка содержит только стандартные символы, то тело цикла можно упростить:
for (char& ch : s) {
    ch = tolower(ch);
} 
Что вернёт вызов ToLowerCase("One, Two, Three!"s)?


Строку "One Two Three"s

Строку "1, 2, 3!"s

Строку "OneTwoThree"s

Строку "One, Two, Three!"s

Правильный ответ
Строку "one, two, three!"s

Строку "one two three"s

Строку "onetwothree"s
Написанное нами решение имеет недостаток: при каждом вызове компаратора создаются две временные строки в нижнем регистре. Затем эти строки сравниваются и больше не используются. Создание строк, особенно длинных, может быть дорогой операцией как с точки зрения памяти, так и времени процессора.
Оптимальнее было бы сравнивать строки без учёта регистра, не создавая временных копий. В этом поможет алгоритм lexicographical_compare. Он лексикографически сравнивает два диапазона элементов и возвращает результат типа bool:
true, если первый диапазон лексикографически предшествует второму.
false в противном случае.
Разберёмся на примере:
#include <algorithm> // Содержит функцию lexicographical_compare
#include <string>
#include <vector>

using namespace std;

int main() {
    // Лексикографически сравниваем векторы чисел
    vector<int> v1 = {3, 14, 15, 92};
    vector<int> v2 = {3, 14, 24};
    bool v1_precedes_v2 = lexicographical_compare(
        v1.begin(), v1.end(), // Первый диапазон
        v2.begin(), v2.end()  // Второй диапазон 
    );
    // Ожидается, что v1_precedes_v2 == true

    // Можно сравнивать и строки. Они рассматриваются как диапазоны символов
    string s1 = "cat"s;
    string s2 = "cafeteria"s;

    bool s1_precedes_s2  = lexicographical_compare(
        s1.begin(), s1.end(),
        s2.begin(), s2.end()
    );
    // Ожидается, что s1_precedes_s2 == false
} 
Пока что польза от этого алгоритма для сравнения строк не совсем очевидна. Мы могли бы написать bool s1_precedes_s2 = (s1 < s2); и получить тот же результат. Однако в lexicographical_compare, как и в sort, можно передать дополнительный аргумент — функцию-компаратор. Этот компаратор должен вернуть true, если элемент из первого диапазона предшествует элементу из второго.
Теперь чтобы сравнить строки без учёта регистра символов, передадим компаратор, игнорирующий регистр:
    string s1 = "cat"s;
    string s2 = "Zebra"s;

    bool s1_precedes_s2  = lexicographical_compare(
        s1.begin(), s1.end(), // Первый диапазон
        s2.begin(), s2.end(), // Второй диапазон
        [](char left, char right) {
            // Сравниваем символы left и right без учёта их регистра.
            // Возвращаем true, если left предшествует right.
        }
    );
    // Ожидается, что s1_precedes_s2 == true 
Примените полученные знания на практике и напишите программу, сортирующую строки без учёта регистра символов.